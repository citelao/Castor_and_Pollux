#!/usr/bin/env python3

# Copyright (c) 2021 Alethea Katherine Flowers.
# Published under the standard MIT License.
# Full text available at: https://opensource.org/licenses/MIT

"""Generates the fallback ../src/gem_voice_param_table.c using the reference
calibration from ../../factory/libgemini."""

import argparse
import pathlib
import sys
import textwrap

TCC_GCLK_FREQUENCY = 8_000_000
TCC_GCLK_DIVISION = 1
TCC_GCLK_RESOLUTION = 2 ** 24
ADC_RESOLUTION = 2 ** 12
ADC_SCALE = 6.0
MIDI_NOTE_RANGE = (12, 96)


def _load_reference_calibration():
    factory_path = pathlib.Path(pathlib.Path(__file__).parent, "../../factory")
    sys.path.insert(1, str(factory_path.resolve()))
    from libgemini import reference_calibration

    return reference_calibration


def _midi_note_to_voltage(note):
    return (note - 12) * (1 / 12)


def _midi_note_to_frequency(note):
    return pow(2, (note - 69) / 12) * 440


def _frequency_to_timer_period(frequency):
    return round(((TCC_GCLK_FREQUENCY / TCC_GCLK_DIVISION) / frequency) - 1)


def _voltage_to_adc_code(voltage):
    return round((ADC_SCALE - voltage) / ADC_SCALE * ADC_RESOLUTION)


def main(output_file):
    reference_calibration = _load_reference_calibration()

    with output_file.open("w") as fh:
        fh.write(
            textwrap.dedent(
                """\
        /* This file is generated by scripts/generate_voice_param_table.py. Do not edit directly. */
        /* clang-format off */

        #include "gem_voice_param_table.h"
        #include "fix16.h"

        const struct GemVoltageAndPeriod gem_voice_voltage_and_period_table[] = {
        """
            )
        )

        for note in range(MIDI_NOTE_RANGE[0], MIDI_NOTE_RANGE[1] + 1):
            voltage = _midi_note_to_voltage(note)
            frequency = _midi_note_to_frequency(note)
            period_reg = _frequency_to_timer_period(frequency)
            fh.write(f"  {{.voltage = F16({voltage:.6f}), .period = {period_reg}}},\n")

        fh.write(
            textwrap.dedent(
                """\
        };

        struct GemDACCodePair gem_voice_dac_codes_table[] = {
        """
            )
        )

        for note in range(MIDI_NOTE_RANGE[0], MIDI_NOTE_RANGE[1] + 1):
            voltage = _midi_note_to_voltage(note)
            frequency = _midi_note_to_frequency(note)
            period_reg = _frequency_to_timer_period(frequency)
            dac_code_castor = reference_calibration.castor[period_reg]
            dac_code_pollux = reference_calibration.pollux[period_reg]
            fh.write(
                f"  {{.castor = {dac_code_castor}, .pollux = {dac_code_pollux} }},\n"
            )

        fh.write(
            textwrap.dedent(
                """\
        };

        size_t gem_voice_param_table_len = sizeof(gem_voice_voltage_and_period_table) / sizeof(struct GemVoltageAndPeriod);

        /* clang-format on */
        """
            )
        )


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser.add_argument(
        "output_file",
        type=pathlib.Path,
    )

    args = parser.parse_args()

    main(args.output_file)
